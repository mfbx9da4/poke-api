export * from "./APIResource";
export * from "./Ability";
export * from "./AbilityEffectChange";
export * from "./AbilityGeneration";
export * from "./AbilityList200Response";
export * from "./AbilityNamesInner";
export * from "./AbilityNamesInnerLanguage";
export * from "./Berry";
export * from "./BerryFirmness";
export * from "./BerryFirmnessList200Response";
export * from "./BerryFlavor";
export * from "./BerryFlavorList200Response";
export * from "./BerryFlavorMap";
export * from "./Characteristic";
export * from "./ContestComboDetail";
export * from "./ContestComboSets";
export * from "./ContestEffect";
export * from "./ContestEffectList200Response";
export * from "./ContestName";
export * from "./ContestType";
export * from "./ContestTypeList200Response";
export * from "./Description";
export * from "./Effect";
export * from "./EffectEffect";
export * from "./EggGroup";
export * from "./Encounter";
export * from "./EncounterCondition";
export * from "./EncounterConditionList200Response";
export * from "./EncounterConditionValue";
export * from "./EncounterMethod";
export * from "./EncounterMethodList200Response";
export * from "./EncounterMethodRate";
export * from "./EncounterVersionDetails";
export * from "./EvolutionChain";
export * from "./EvolutionChainBabyTriggerItem";
export * from "./EvolutionChainChain";
export * from "./EvolutionChainChainEvolutionDetailsInner";
export * from "./EvolutionChainChainEvolutionDetailsInnerItem";
export * from "./EvolutionChainChainEvolutionDetailsInnerKnownMove";
export * from "./EvolutionChainChainEvolutionDetailsInnerKnownMoveType";
export * from "./EvolutionChainChainEvolutionDetailsInnerLocation";
export * from "./EvolutionChainChainEvolutionDetailsInnerPartySpecies";
export * from "./EvolutionChainList200Response";
export * from "./EvolutionTrigger";
export * from "./EvolutionTriggerList200Response";
export * from "./FlavorText";
export * from "./Gender";
export * from "./GenderList200Response";
export * from "./GenderPokemonSpeciesDetailsInner";
export * from "./Generation";
export * from "./GenerationAbilitiesInner";
export * from "./GenerationGameIndex";
export * from "./GenerationList200Response";
export * from "./GenerationNamesInner";
export * from "./Genus";
export * from "./GrowthRate";
export * from "./GrowthRateList200Response";
export * from "./IDOrName";
export * from "./IDOrName1";
export * from "./IDOrName2";
export * from "./Item";
export * from "./ItemAttribute";
export * from "./ItemAttributeList200Response";
export * from "./ItemCategory";
export * from "./ItemCategoryList200Response";
export * from "./ItemFlingEffect";
export * from "./ItemFlingEffectList200Response";
export * from "./ItemList200Response";
export * from "./ItemPocket";
export * from "./ItemPocketList200Response";
export * from "./Language";
export * from "./LanguageList200Response";
export * from "./Location";
export * from "./LocationArea";
export * from "./LocationAreaList200Response";
export * from "./LocationList200Response";
export * from "./Machine";
export * from "./MachineList200Response";
export * from "./MachineVersionDetail";
export * from "./Move";
export * from "./MoveAilment";
export * from "./MoveAilmentList200Response";
export * from "./MoveBattleStyle";
export * from "./MoveBattleStyleList200Response";
export * from "./MoveBattleStylePreference";
export * from "./MoveCategory";
export * from "./MoveCategoryList200Response";
export * from "./MoveContestEffect";
export * from "./MoveContestType";
export * from "./MoveDamageClass";
export * from "./MoveDamageClassList200Response";
export * from "./MoveLearnMethod";
export * from "./MoveLearnMethodList200Response";
export * from "./MoveList200Response";
export * from "./MoveMetaData";
export * from "./MoveStatAffect";
export * from "./MoveStatAffectSets";
export * from "./MoveStatChange";
export * from "./MoveTarget";
export * from "./MoveTargetList200Response";
export * from "./Name";
export * from "./NamedAPIResource";
export * from "./Nature";
export * from "./NatureList200Response";
export * from "./NaturePokeathlonStatAffectSets";
export * from "./NatureStatAffect";
export * from "./NatureStatAffectSets";
export * from "./NatureStatChange";
export * from "./PalParkArea";
export * from "./PalParkAreaList200Response";
export * from "./PalParkEncounterArea";
export * from "./PastMoveStatValues";
export * from "./PastMoveStatValuesEffectEntriesInner";
export * from "./PokeAthlon";
export * from "./PokeathlonStat";
export * from "./PokeathlonStatAffect";
export * from "./PokeathlonStatAffectingNatures";
export * from "./PokeathlonStatList200Response";
export * from "./PokeathlonStatName";
export * from "./Pokedex";
export * from "./PokedexList200Response";
export * from "./Pokemon";
export * from "./PokemonAbility";
export * from "./PokemonColor";
export * from "./PokemonColorList200Response";
export * from "./PokemonEncounter";
export * from "./PokemonEntry";
export * from "./PokemonForm";
export * from "./PokemonFormList200Response";
export * from "./PokemonHabitat";
export * from "./PokemonHabitatList200Response";
export * from "./PokemonHeldItem";
export * from "./PokemonHeldItemVersionDetailsInner";
export * from "./PokemonList200Response";
export * from "./PokemonMove";
export * from "./PokemonMoveVersionGroupDetailsInner";
export * from "./PokemonShape";
export * from "./PokemonShapeList200Response";
export * from "./PokemonSpecies";
export * from "./PokemonSpeciesDexEntry";
export * from "./PokemonSpeciesList200Response";
export * from "./PokemonSpeciesVariety";
export * from "./PokemonSprites";
export * from "./PokemonStat";
export * from "./PokemonType";
export * from "./Region";
export * from "./RegionList200Response";
export * from "./Stat";
export * from "./StatList200Response";
export * from "./SuperContestEffect";
export * from "./SuperContestEffectList200Response";
export * from "./Type";
export * from "./TypeDamageRelations";
export * from "./TypeDamageRelationsDoubleDamageFromInner";
export * from "./TypeGameIndicesInner";
export * from "./TypeGameIndicesInnerGeneration";
export * from "./TypeGeneration";
export * from "./TypeList200Response";
export * from "./TypeMoveDamageClass";
export * from "./TypePokemonInner";
export * from "./VerboseEffect";
export * from "./Version";
export * from "./VersionGameIndex";
export * from "./VersionGroup";
export * from "./VersionGroupList200Response";
export * from "./VersionList200Response";

import { APIResource } from "./APIResource";
import { Ability } from "./Ability";
import { AbilityEffectChange } from "./AbilityEffectChange";
import { AbilityGeneration } from "./AbilityGeneration";
import { AbilityList200Response } from "./AbilityList200Response";
import { AbilityNamesInner } from "./AbilityNamesInner";
import { AbilityNamesInnerLanguage } from "./AbilityNamesInnerLanguage";
import { Berry } from "./Berry";
import { BerryFirmness } from "./BerryFirmness";
import { BerryFirmnessList200Response } from "./BerryFirmnessList200Response";
import { BerryFlavor } from "./BerryFlavor";
import { BerryFlavorList200Response } from "./BerryFlavorList200Response";
import { BerryFlavorMap } from "./BerryFlavorMap";
import { Characteristic } from "./Characteristic";
import { ContestComboDetail } from "./ContestComboDetail";
import { ContestComboSets } from "./ContestComboSets";
import { ContestEffect } from "./ContestEffect";
import { ContestEffectList200Response } from "./ContestEffectList200Response";
import { ContestName } from "./ContestName";
import { ContestType } from "./ContestType";
import { ContestTypeList200Response } from "./ContestTypeList200Response";
import { Description } from "./Description";
import { Effect } from "./Effect";
import { EffectEffect } from "./EffectEffect";
import { EggGroup } from "./EggGroup";
import { Encounter } from "./Encounter";
import { EncounterCondition } from "./EncounterCondition";
import { EncounterConditionList200Response } from "./EncounterConditionList200Response";
import { EncounterConditionValue } from "./EncounterConditionValue";
import { EncounterMethod } from "./EncounterMethod";
import { EncounterMethodList200Response } from "./EncounterMethodList200Response";
import { EncounterMethodRate } from "./EncounterMethodRate";
import { EncounterVersionDetails } from "./EncounterVersionDetails";
import { EvolutionChain } from "./EvolutionChain";
import { EvolutionChainBabyTriggerItem } from "./EvolutionChainBabyTriggerItem";
import { EvolutionChainChain } from "./EvolutionChainChain";
import {
  EvolutionChainChainEvolutionDetailsInner,
  EvolutionChainChainEvolutionDetailsInnerTimeOfDayEnum,
} from "./EvolutionChainChainEvolutionDetailsInner";
import { EvolutionChainChainEvolutionDetailsInnerItem } from "./EvolutionChainChainEvolutionDetailsInnerItem";
import { EvolutionChainChainEvolutionDetailsInnerKnownMove } from "./EvolutionChainChainEvolutionDetailsInnerKnownMove";
import { EvolutionChainChainEvolutionDetailsInnerKnownMoveType } from "./EvolutionChainChainEvolutionDetailsInnerKnownMoveType";
import { EvolutionChainChainEvolutionDetailsInnerLocation } from "./EvolutionChainChainEvolutionDetailsInnerLocation";
import { EvolutionChainChainEvolutionDetailsInnerPartySpecies } from "./EvolutionChainChainEvolutionDetailsInnerPartySpecies";
import { EvolutionChainList200Response } from "./EvolutionChainList200Response";
import { EvolutionTrigger } from "./EvolutionTrigger";
import { EvolutionTriggerList200Response } from "./EvolutionTriggerList200Response";
import { FlavorText } from "./FlavorText";
import { Gender } from "./Gender";
import { GenderList200Response } from "./GenderList200Response";
import { GenderPokemonSpeciesDetailsInner } from "./GenderPokemonSpeciesDetailsInner";
import { Generation } from "./Generation";
import { GenerationAbilitiesInner } from "./GenerationAbilitiesInner";
import { GenerationGameIndex } from "./GenerationGameIndex";
import { GenerationList200Response } from "./GenerationList200Response";
import { GenerationNamesInner } from "./GenerationNamesInner";
import { Genus } from "./Genus";
import { GrowthRate } from "./GrowthRate";
import { GrowthRateList200Response } from "./GrowthRateList200Response";
import { IDOrName } from "./IDOrName";
import { IDOrName1 } from "./IDOrName1";
import { IDOrName2 } from "./IDOrName2";
import { Item } from "./Item";
import { ItemAttribute } from "./ItemAttribute";
import { ItemAttributeList200Response } from "./ItemAttributeList200Response";
import { ItemCategory } from "./ItemCategory";
import { ItemCategoryList200Response } from "./ItemCategoryList200Response";
import { ItemFlingEffect } from "./ItemFlingEffect";
import { ItemFlingEffectList200Response } from "./ItemFlingEffectList200Response";
import { ItemList200Response } from "./ItemList200Response";
import { ItemPocket } from "./ItemPocket";
import { ItemPocketList200Response } from "./ItemPocketList200Response";
import { Language } from "./Language";
import { LanguageList200Response } from "./LanguageList200Response";
import { Location } from "./Location";
import { LocationArea } from "./LocationArea";
import { LocationAreaList200Response } from "./LocationAreaList200Response";
import { LocationList200Response } from "./LocationList200Response";
import { Machine } from "./Machine";
import { MachineList200Response } from "./MachineList200Response";
import { MachineVersionDetail } from "./MachineVersionDetail";
import { Move } from "./Move";
import { MoveAilment } from "./MoveAilment";
import { MoveAilmentList200Response } from "./MoveAilmentList200Response";
import { MoveBattleStyle } from "./MoveBattleStyle";
import { MoveBattleStyleList200Response } from "./MoveBattleStyleList200Response";
import { MoveBattleStylePreference } from "./MoveBattleStylePreference";
import { MoveCategory } from "./MoveCategory";
import { MoveCategoryList200Response } from "./MoveCategoryList200Response";
import { MoveContestEffect } from "./MoveContestEffect";
import { MoveContestType } from "./MoveContestType";
import { MoveDamageClass } from "./MoveDamageClass";
import { MoveDamageClassList200Response } from "./MoveDamageClassList200Response";
import { MoveLearnMethod } from "./MoveLearnMethod";
import { MoveLearnMethodList200Response } from "./MoveLearnMethodList200Response";
import { MoveList200Response } from "./MoveList200Response";
import { MoveMetaData } from "./MoveMetaData";
import { MoveStatAffect } from "./MoveStatAffect";
import { MoveStatAffectSets } from "./MoveStatAffectSets";
import { MoveStatChange } from "./MoveStatChange";
import { MoveTarget } from "./MoveTarget";
import { MoveTargetList200Response } from "./MoveTargetList200Response";
import { Name } from "./Name";
import { NamedAPIResource } from "./NamedAPIResource";
import { Nature } from "./Nature";
import { NatureList200Response } from "./NatureList200Response";
import { NaturePokeathlonStatAffectSets } from "./NaturePokeathlonStatAffectSets";
import { NatureStatAffect } from "./NatureStatAffect";
import { NatureStatAffectSets } from "./NatureStatAffectSets";
import { NatureStatChange } from "./NatureStatChange";
import { PalParkArea } from "./PalParkArea";
import { PalParkAreaList200Response } from "./PalParkAreaList200Response";
import { PalParkEncounterArea } from "./PalParkEncounterArea";
import { PastMoveStatValues } from "./PastMoveStatValues";
import { PastMoveStatValuesEffectEntriesInner } from "./PastMoveStatValuesEffectEntriesInner";
import { PokeAthlon } from "./PokeAthlon";
import { PokeathlonStat } from "./PokeathlonStat";
import { PokeathlonStatAffect } from "./PokeathlonStatAffect";
import { PokeathlonStatAffectingNatures } from "./PokeathlonStatAffectingNatures";
import { PokeathlonStatList200Response } from "./PokeathlonStatList200Response";
import { PokeathlonStatName } from "./PokeathlonStatName";
import { Pokedex } from "./Pokedex";
import { PokedexList200Response } from "./PokedexList200Response";
import { Pokemon } from "./Pokemon";
import { PokemonAbility } from "./PokemonAbility";
import { PokemonColor } from "./PokemonColor";
import { PokemonColorList200Response } from "./PokemonColorList200Response";
import { PokemonEncounter } from "./PokemonEncounter";
import { PokemonEntry } from "./PokemonEntry";
import { PokemonForm } from "./PokemonForm";
import { PokemonFormList200Response } from "./PokemonFormList200Response";
import { PokemonHabitat } from "./PokemonHabitat";
import { PokemonHabitatList200Response } from "./PokemonHabitatList200Response";
import { PokemonHeldItem } from "./PokemonHeldItem";
import { PokemonHeldItemVersionDetailsInner } from "./PokemonHeldItemVersionDetailsInner";
import { PokemonList200Response } from "./PokemonList200Response";
import { PokemonMove } from "./PokemonMove";
import { PokemonMoveVersionGroupDetailsInner } from "./PokemonMoveVersionGroupDetailsInner";
import { PokemonShape } from "./PokemonShape";
import { PokemonShapeList200Response } from "./PokemonShapeList200Response";
import { PokemonSpecies } from "./PokemonSpecies";
import { PokemonSpeciesDexEntry } from "./PokemonSpeciesDexEntry";
import { PokemonSpeciesList200Response } from "./PokemonSpeciesList200Response";
import { PokemonSpeciesVariety } from "./PokemonSpeciesVariety";
import { PokemonSprites } from "./PokemonSprites";
import { PokemonStat } from "./PokemonStat";
import { PokemonType } from "./PokemonType";
import { Region } from "./Region";
import { RegionList200Response } from "./RegionList200Response";
import { Stat } from "./Stat";
import { StatList200Response } from "./StatList200Response";
import { SuperContestEffect } from "./SuperContestEffect";
import { SuperContestEffectList200Response } from "./SuperContestEffectList200Response";
import { Type } from "./Type";
import { TypeDamageRelations } from "./TypeDamageRelations";
import { TypeDamageRelationsDoubleDamageFromInner } from "./TypeDamageRelationsDoubleDamageFromInner";
import { TypeGameIndicesInner } from "./TypeGameIndicesInner";
import { TypeGameIndicesInnerGeneration } from "./TypeGameIndicesInnerGeneration";
import { TypeGeneration } from "./TypeGeneration";
import { TypeList200Response } from "./TypeList200Response";
import { TypeMoveDamageClass } from "./TypeMoveDamageClass";
import { TypePokemonInner } from "./TypePokemonInner";
import { VerboseEffect } from "./VerboseEffect";
import { Version } from "./Version";
import { VersionGameIndex } from "./VersionGameIndex";
import { VersionGroup } from "./VersionGroup";
import { VersionGroupList200Response } from "./VersionGroupList200Response";
import { VersionList200Response } from "./VersionList200Response";

/* tslint:disable:no-unused-variable */
let primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any",
];

let enumsMap: Set<string> = new Set<string>([
  "EvolutionChainChainEvolutionDetailsInnerTimeOfDayEnum",
]);

let typeMap: { [index: string]: any } = {
  APIResource: APIResource,
  Ability: Ability,
  AbilityEffectChange: AbilityEffectChange,
  AbilityGeneration: AbilityGeneration,
  AbilityList200Response: AbilityList200Response,
  AbilityNamesInner: AbilityNamesInner,
  AbilityNamesInnerLanguage: AbilityNamesInnerLanguage,
  Berry: Berry,
  BerryFirmness: BerryFirmness,
  BerryFirmnessList200Response: BerryFirmnessList200Response,
  BerryFlavor: BerryFlavor,
  BerryFlavorList200Response: BerryFlavorList200Response,
  BerryFlavorMap: BerryFlavorMap,
  Characteristic: Characteristic,
  ContestComboDetail: ContestComboDetail,
  ContestComboSets: ContestComboSets,
  ContestEffect: ContestEffect,
  ContestEffectList200Response: ContestEffectList200Response,
  ContestName: ContestName,
  ContestType: ContestType,
  ContestTypeList200Response: ContestTypeList200Response,
  Description: Description,
  Effect: Effect,
  EffectEffect: EffectEffect,
  EggGroup: EggGroup,
  Encounter: Encounter,
  EncounterCondition: EncounterCondition,
  EncounterConditionList200Response: EncounterConditionList200Response,
  EncounterConditionValue: EncounterConditionValue,
  EncounterMethod: EncounterMethod,
  EncounterMethodList200Response: EncounterMethodList200Response,
  EncounterMethodRate: EncounterMethodRate,
  EncounterVersionDetails: EncounterVersionDetails,
  EvolutionChain: EvolutionChain,
  EvolutionChainBabyTriggerItem: EvolutionChainBabyTriggerItem,
  EvolutionChainChain: EvolutionChainChain,
  EvolutionChainChainEvolutionDetailsInner:
    EvolutionChainChainEvolutionDetailsInner,
  EvolutionChainChainEvolutionDetailsInnerItem:
    EvolutionChainChainEvolutionDetailsInnerItem,
  EvolutionChainChainEvolutionDetailsInnerKnownMove:
    EvolutionChainChainEvolutionDetailsInnerKnownMove,
  EvolutionChainChainEvolutionDetailsInnerKnownMoveType:
    EvolutionChainChainEvolutionDetailsInnerKnownMoveType,
  EvolutionChainChainEvolutionDetailsInnerLocation:
    EvolutionChainChainEvolutionDetailsInnerLocation,
  EvolutionChainChainEvolutionDetailsInnerPartySpecies:
    EvolutionChainChainEvolutionDetailsInnerPartySpecies,
  EvolutionChainList200Response: EvolutionChainList200Response,
  EvolutionTrigger: EvolutionTrigger,
  EvolutionTriggerList200Response: EvolutionTriggerList200Response,
  FlavorText: FlavorText,
  Gender: Gender,
  GenderList200Response: GenderList200Response,
  GenderPokemonSpeciesDetailsInner: GenderPokemonSpeciesDetailsInner,
  Generation: Generation,
  GenerationAbilitiesInner: GenerationAbilitiesInner,
  GenerationGameIndex: GenerationGameIndex,
  GenerationList200Response: GenerationList200Response,
  GenerationNamesInner: GenerationNamesInner,
  Genus: Genus,
  GrowthRate: GrowthRate,
  GrowthRateList200Response: GrowthRateList200Response,
  IDOrName: IDOrName,
  IDOrName1: IDOrName1,
  IDOrName2: IDOrName2,
  Item: Item,
  ItemAttribute: ItemAttribute,
  ItemAttributeList200Response: ItemAttributeList200Response,
  ItemCategory: ItemCategory,
  ItemCategoryList200Response: ItemCategoryList200Response,
  ItemFlingEffect: ItemFlingEffect,
  ItemFlingEffectList200Response: ItemFlingEffectList200Response,
  ItemList200Response: ItemList200Response,
  ItemPocket: ItemPocket,
  ItemPocketList200Response: ItemPocketList200Response,
  Language: Language,
  LanguageList200Response: LanguageList200Response,
  Location: Location,
  LocationArea: LocationArea,
  LocationAreaList200Response: LocationAreaList200Response,
  LocationList200Response: LocationList200Response,
  Machine: Machine,
  MachineList200Response: MachineList200Response,
  MachineVersionDetail: MachineVersionDetail,
  Move: Move,
  MoveAilment: MoveAilment,
  MoveAilmentList200Response: MoveAilmentList200Response,
  MoveBattleStyle: MoveBattleStyle,
  MoveBattleStyleList200Response: MoveBattleStyleList200Response,
  MoveBattleStylePreference: MoveBattleStylePreference,
  MoveCategory: MoveCategory,
  MoveCategoryList200Response: MoveCategoryList200Response,
  MoveContestEffect: MoveContestEffect,
  MoveContestType: MoveContestType,
  MoveDamageClass: MoveDamageClass,
  MoveDamageClassList200Response: MoveDamageClassList200Response,
  MoveLearnMethod: MoveLearnMethod,
  MoveLearnMethodList200Response: MoveLearnMethodList200Response,
  MoveList200Response: MoveList200Response,
  MoveMetaData: MoveMetaData,
  MoveStatAffect: MoveStatAffect,
  MoveStatAffectSets: MoveStatAffectSets,
  MoveStatChange: MoveStatChange,
  MoveTarget: MoveTarget,
  MoveTargetList200Response: MoveTargetList200Response,
  Name: Name,
  NamedAPIResource: NamedAPIResource,
  Nature: Nature,
  NatureList200Response: NatureList200Response,
  NaturePokeathlonStatAffectSets: NaturePokeathlonStatAffectSets,
  NatureStatAffect: NatureStatAffect,
  NatureStatAffectSets: NatureStatAffectSets,
  NatureStatChange: NatureStatChange,
  PalParkArea: PalParkArea,
  PalParkAreaList200Response: PalParkAreaList200Response,
  PalParkEncounterArea: PalParkEncounterArea,
  PastMoveStatValues: PastMoveStatValues,
  PastMoveStatValuesEffectEntriesInner: PastMoveStatValuesEffectEntriesInner,
  PokeAthlon: PokeAthlon,
  PokeathlonStat: PokeathlonStat,
  PokeathlonStatAffect: PokeathlonStatAffect,
  PokeathlonStatAffectingNatures: PokeathlonStatAffectingNatures,
  PokeathlonStatList200Response: PokeathlonStatList200Response,
  PokeathlonStatName: PokeathlonStatName,
  Pokedex: Pokedex,
  PokedexList200Response: PokedexList200Response,
  Pokemon: Pokemon,
  PokemonAbility: PokemonAbility,
  PokemonColor: PokemonColor,
  PokemonColorList200Response: PokemonColorList200Response,
  PokemonEncounter: PokemonEncounter,
  PokemonEntry: PokemonEntry,
  PokemonForm: PokemonForm,
  PokemonFormList200Response: PokemonFormList200Response,
  PokemonHabitat: PokemonHabitat,
  PokemonHabitatList200Response: PokemonHabitatList200Response,
  PokemonHeldItem: PokemonHeldItem,
  PokemonHeldItemVersionDetailsInner: PokemonHeldItemVersionDetailsInner,
  PokemonList200Response: PokemonList200Response,
  PokemonMove: PokemonMove,
  PokemonMoveVersionGroupDetailsInner: PokemonMoveVersionGroupDetailsInner,
  PokemonShape: PokemonShape,
  PokemonShapeList200Response: PokemonShapeList200Response,
  PokemonSpecies: PokemonSpecies,
  PokemonSpeciesDexEntry: PokemonSpeciesDexEntry,
  PokemonSpeciesList200Response: PokemonSpeciesList200Response,
  PokemonSpeciesVariety: PokemonSpeciesVariety,
  PokemonSprites: PokemonSprites,
  PokemonStat: PokemonStat,
  PokemonType: PokemonType,
  Region: Region,
  RegionList200Response: RegionList200Response,
  Stat: Stat,
  StatList200Response: StatList200Response,
  SuperContestEffect: SuperContestEffect,
  SuperContestEffectList200Response: SuperContestEffectList200Response,
  Type: Type,
  TypeDamageRelations: TypeDamageRelations,
  TypeDamageRelationsDoubleDamageFromInner:
    TypeDamageRelationsDoubleDamageFromInner,
  TypeGameIndicesInner: TypeGameIndicesInner,
  TypeGameIndicesInnerGeneration: TypeGameIndicesInnerGeneration,
  TypeGeneration: TypeGeneration,
  TypeList200Response: TypeList200Response,
  TypeMoveDamageClass: TypeMoveDamageClass,
  TypePokemonInner: TypePokemonInner,
  VerboseEffect: VerboseEffect,
  Version: Version,
  VersionGameIndex: VersionGameIndex,
  VersionGroup: VersionGroup,
  VersionGroupList200Response: VersionGroupList200Response,
  VersionList200Response: VersionList200Response,
};

type MimeTypeDescriptor = {
  type: string;
  subtype: string;
  subtypeTokens: string[];
};

/**
 * Every mime-type consists of a type, subtype, and optional parameters.
 * The subtype can be composite, including information about the content format.
 * For example: `application/json-patch+json`, `application/merge-patch+json`.
 *
 * This helper transforms a string mime-type into an internal representation.
 * This simplifies the implementation of predicates that in turn define common rules for parsing or stringifying
 * the payload.
 */
const parseMimeType = (mimeType: string): MimeTypeDescriptor => {
  const [type, subtype] = mimeType.split("/");
  return {
    type,
    subtype,
    subtypeTokens: subtype.split("+"),
  };
};

type MimeTypePredicate = (mimeType: string) => boolean;

// This factory creates a predicate function that checks a string mime-type against defined rules.
const mimeTypePredicateFactory =
  (predicate: (descriptor: MimeTypeDescriptor) => boolean): MimeTypePredicate =>
  (mimeType) =>
    predicate(parseMimeType(mimeType));

// Use this factory when you need to define a simple predicate based only on type and, if applicable, subtype.
const mimeTypeSimplePredicateFactory = (
  type: string,
  subtype?: string
): MimeTypePredicate =>
  mimeTypePredicateFactory((descriptor) => {
    if (descriptor.type !== type) return false;
    if (subtype != null && descriptor.subtype !== subtype) return false;
    return true;
  });

// Creating a set of named predicates that will help us determine how to handle different mime-types
const isTextLikeMimeType = mimeTypeSimplePredicateFactory("text");
const isJsonMimeType = mimeTypeSimplePredicateFactory("application", "json");
const isJsonLikeMimeType = mimeTypePredicateFactory(
  (descriptor) =>
    descriptor.type === "application" &&
    descriptor.subtypeTokens.some((item) => item === "json")
);
const isOctetStreamMimeType = mimeTypeSimplePredicateFactory(
  "application",
  "octet-stream"
);
const isFormUrlencodedMimeType = mimeTypeSimplePredicateFactory(
  "application",
  "x-www-form-urlencoded"
);

// Defining a list of mime-types in the order of prioritization for handling.
const supportedMimeTypePredicatesWithPriority: MimeTypePredicate[] = [
  isJsonMimeType,
  isJsonLikeMimeType,
  isTextLikeMimeType,
  isOctetStreamMimeType,
  isFormUrlencodedMimeType,
];

export class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap.has(expectedType)) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          var discriminatorType = data[discriminatorProperty];
          if (typeMap[discriminatorType]) {
            return discriminatorType; // use the type given in the discriminator
          } else {
            return expectedType; // discriminator did not map to a type
          }
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string, format: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let date of data) {
        transformedData.push(ObjectSerializer.serialize(date, subType, format));
      }
      return transformedData;
    } else if (type === "Date") {
      if (format == "date") {
        let month = data.getMonth() + 1;
        month = month < 10 ? "0" + month.toString() : month.toString();
        let day = data.getDate();
        day = day < 10 ? "0" + day.toString() : day.toString();

        return data.getFullYear() + "-" + month + "-" + day;
      } else {
        return data.toISOString();
      }
    } else {
      if (enumsMap.has(type)) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // Get the actual type of this object
      type = this.findCorrectType(data, type);

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let attributeType of attributeTypes) {
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type,
          attributeType.format
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string, format: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let date of data) {
        transformedData.push(
          ObjectSerializer.deserialize(date, subType, format)
        );
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap.has(type)) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let attributeType of attributeTypes) {
        let value = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type,
          attributeType.format
        );
        if (value !== undefined) {
          instance[attributeType.name] = value;
        }
      }
      return instance;
    }
  }

  /**
   * Normalize media type
   *
   * We currently do not handle any media types attributes, i.e. anything
   * after a semicolon. All content is assumed to be UTF-8 compatible.
   */
  public static normalizeMediaType(
    mediaType: string | undefined
  ): string | undefined {
    if (mediaType === undefined) {
      return undefined;
    }
    return mediaType.split(";")[0].trim().toLowerCase();
  }

  /**
   * From a list of possible media types, choose the one we can handle best.
   *
   * The order of the given media types does not have any impact on the choice
   * made.
   */
  public static getPreferredMediaType(mediaTypes: Array<string>): string {
    /** According to OAS 3 we should default to json */
    if (mediaTypes.length === 0) {
      return "application/json";
    }

    const normalMediaTypes = mediaTypes.map(this.normalizeMediaType);

    for (const predicate of supportedMimeTypePredicatesWithPriority) {
      for (const mediaType of normalMediaTypes) {
        if (mediaType != null && predicate(mediaType)) {
          return mediaType;
        }
      }
    }

    throw new Error(
      "None of the given media types are supported: " + mediaTypes.join(", ")
    );
  }

  /**
   * Convert data to a string according the given media type
   */
  public static stringify(data: any, mediaType: string): string {
    if (isTextLikeMimeType(mediaType)) {
      return String(data);
    }

    if (isJsonLikeMimeType(mediaType)) {
      return JSON.stringify(data);
    }

    throw new Error(
      "The mediaType " +
        mediaType +
        " is not supported by ObjectSerializer.stringify."
    );
  }

  /**
   * Parse data from a string according to the given media type
   */
  public static parse(rawData: string, mediaType: string | undefined) {
    if (mediaType === undefined) {
      throw new Error("Cannot parse content. No Content-Type defined.");
    }

    if (isTextLikeMimeType(mediaType)) {
      return rawData;
    }

    if (isJsonLikeMimeType(mediaType)) {
      return JSON.parse(rawData);
    }

    throw new Error(
      "The mediaType " +
        mediaType +
        " is not supported by ObjectSerializer.parse."
    );
  }
}
